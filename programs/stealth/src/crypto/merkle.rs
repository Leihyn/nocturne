//! Sparse Merkle Tree Implementation
//!
//! A memory-efficient Merkle tree for storing note commitments.
//! Uses Poseidon hash for ZK circuit compatibility.
//!
//! Tree Properties:
//! - Depth: 10 levels (supports 1024 notes)
//! - Hash: Poseidon (BN254 compatible with circom/snarkjs)
//! - Storage: Only non-zero leaves are stored

use anchor_lang::prelude::*;
use super::poseidon::poseidon_hash_2;

/// Merkle tree depth (2^8 = 256 notes per pool)
/// Reduced from 10 to fit Solana compute budget (~560k CUs for 8 levels)
/// Must match frontend and circuit MERKLE_DEPTH
pub const MERKLE_DEPTH: usize = 8;

/// Maximum number of leaves
pub const MAX_LEAVES: u64 = 1 << MERKLE_DEPTH;

/// Zero hash for empty leaves
pub const ZERO_VALUE: [u8; 32] = [0u8; 32];

/// Poseidon hash of two 32-byte values (for merkle tree)
/// Compatible with circom Poseidon implementation
#[inline(never)]
pub fn merkle_hash_2(left: &[u8; 32], right: &[u8; 32]) -> [u8; 32] {
    poseidon_hash_2(left, right)
}

/// Pre-computed Poseidon zero hashes for each level of the Merkle tree
/// zero_hashes[0] = [0u8; 32] (empty leaf)
/// zero_hashes[i] = poseidon(zero_hashes[i-1], zero_hashes[i-1])
///
/// These values are pre-computed using circomlibjs Poseidon (BN254 compatible)
/// and MUST match the frontend's getZeroHashes().
/// Generated by scripts/compute-zero-hashes.mjs
///
/// IMPORTANT: Using pre-computed values saves ~1M compute units vs runtime computation!
pub static ZERO_HASHES: [[u8; 32]; MERKLE_DEPTH + 1] = [
    // Level 0: Zero value (empty leaf)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // Level 1: poseidon(zeros[0], zeros[0])
    [0x20, 0x98, 0xf5, 0xfb, 0x9e, 0x23, 0x9e, 0xab, 0x3c, 0xea, 0xc3, 0xf2, 0x7b, 0x81, 0xe4, 0x81, 0xdc, 0x31, 0x24, 0xd5, 0x5f, 0xfe, 0xd5, 0x23, 0xa8, 0x39, 0xee, 0x84, 0x46, 0xb6, 0x48, 0x64],
    // Level 2: poseidon(zeros[1], zeros[1])
    [0x10, 0x69, 0x67, 0x3d, 0xcd, 0xb1, 0x22, 0x63, 0xdf, 0x30, 0x1a, 0x6f, 0xf5, 0x84, 0xa7, 0xec, 0x26, 0x1a, 0x44, 0xcb, 0x9d, 0xc6, 0x8d, 0xf0, 0x67, 0xa4, 0x77, 0x44, 0x60, 0xb1, 0xf1, 0xe1],
    // Level 3: poseidon(zeros[2], zeros[2])
    [0x18, 0xf4, 0x33, 0x31, 0x53, 0x7e, 0xe2, 0xaf, 0x2e, 0x3d, 0x75, 0x8d, 0x50, 0xf7, 0x21, 0x06, 0x46, 0x7c, 0x6e, 0xea, 0x50, 0x37, 0x1d, 0xd5, 0x28, 0xd5, 0x7e, 0xb2, 0xb8, 0x56, 0xd2, 0x38],
    // Level 4: poseidon(zeros[3], zeros[3])
    [0x07, 0xf9, 0xd8, 0x37, 0xcb, 0x17, 0xb0, 0xd3, 0x63, 0x20, 0xff, 0xe9, 0x3b, 0xa5, 0x23, 0x45, 0xf1, 0xb7, 0x28, 0x57, 0x1a, 0x56, 0x82, 0x65, 0xca, 0xac, 0x97, 0x55, 0x9d, 0xbc, 0x95, 0x2a],
    // Level 5: poseidon(zeros[4], zeros[4])
    [0x2b, 0x94, 0xcf, 0x5e, 0x87, 0x46, 0xb3, 0xf5, 0xc9, 0x63, 0x1f, 0x4c, 0x5d, 0xf3, 0x29, 0x07, 0xa6, 0x99, 0xc5, 0x8c, 0x94, 0xb2, 0xad, 0x4d, 0x7b, 0x5c, 0xec, 0x16, 0x39, 0x18, 0x3f, 0x55],
    // Level 6: poseidon(zeros[5], zeros[5])
    [0x2d, 0xee, 0x93, 0xc5, 0xa6, 0x66, 0x45, 0x96, 0x46, 0xea, 0x7d, 0x22, 0xcc, 0xa9, 0xe1, 0xbc, 0xfe, 0xd7, 0x1e, 0x69, 0x51, 0xb9, 0x53, 0x61, 0x1d, 0x11, 0xdd, 0xa3, 0x2e, 0xa0, 0x9d, 0x78],
    // Level 7: poseidon(zeros[6], zeros[6])
    [0x07, 0x82, 0x95, 0xe5, 0xa2, 0x2b, 0x84, 0xe9, 0x82, 0xcf, 0x60, 0x1e, 0xb6, 0x39, 0x59, 0x7b, 0x8b, 0x05, 0x15, 0xa8, 0x8c, 0xb5, 0xac, 0x7f, 0xa8, 0xa4, 0xaa, 0xbe, 0x3c, 0x87, 0x34, 0x9d],
    // Level 8: poseidon(zeros[7], zeros[7]) - This is the empty tree root
    [0x2f, 0xa5, 0xe5, 0xf1, 0x8f, 0x60, 0x27, 0xa6, 0x50, 0x1b, 0xec, 0x86, 0x45, 0x64, 0x47, 0x2a, 0x61, 0x6b, 0x2e, 0x27, 0x4a, 0x41, 0x21, 0x1a, 0x44, 0x4c, 0xbe, 0x3a, 0x99, 0xf3, 0xcc, 0x61],
];

/// Empty tree root (zeros[MERKLE_DEPTH]) - pre-computed for quick access
pub const EMPTY_TREE_ROOT: [u8; 32] = [0x2f, 0xa5, 0xe5, 0xf1, 0x8f, 0x60, 0x27, 0xa6, 0x50, 0x1b, 0xec, 0x86, 0x45, 0x64, 0x47, 0x2a, 0x61, 0x6b, 0x2e, 0x27, 0x4a, 0x41, 0x21, 0x1a, 0x44, 0x4c, 0xbe, 0x3a, 0x99, 0xf3, 0xcc, 0x61];

/// Get pre-computed zero hashes (NO runtime computation - saves ~1M CUs!)
/// Use this for pool initialization instead of compute_zero_hashes_poseidon()
#[inline(always)]
pub fn get_precomputed_zero_hashes() -> &'static [[u8; 32]; MERKLE_DEPTH + 1] {
    &ZERO_HASHES
}

/// Compute zero hashes dynamically using Poseidon
/// WARNING: This is VERY expensive (~1.4M CUs)! Use get_precomputed_zero_hashes() instead.
/// Only use this for verification/testing purposes.
#[inline(never)]
pub fn compute_zero_hashes_poseidon() -> [[u8; 32]; MERKLE_DEPTH + 1] {
    // Return pre-computed values to save compute units
    // The values in ZERO_HASHES were generated using the same Poseidon implementation
    ZERO_HASHES
}

/// Get zero hash for a specific level (uses pre-computed values)
#[inline(always)]
pub fn get_zero_hash(level: usize) -> [u8; 32] {
    ZERO_HASHES[level]
}

/// Returns pre-computed zero hashes (alias for backwards compatibility)
#[inline(always)]
pub fn compute_zero_hashes() -> [[u8; 32]; MERKLE_DEPTH + 1] {
    ZERO_HASHES
}

/// Merkle proof for a leaf
#[derive(Clone, Debug, AnchorSerialize, AnchorDeserialize)]
pub struct MerkleProof {
    /// Sibling hashes from leaf to root
    pub siblings: [[u8; 32]; MERKLE_DEPTH],
    /// Path indices (0 = left, 1 = right)
    pub path_indices: [u8; MERKLE_DEPTH],
}

impl MerkleProof {
    /// Verify a proof against a root
    pub fn verify(&self, leaf: &[u8; 32], root: &[u8; 32]) -> bool {
        let computed = self.compute_root(leaf);
        computed == *root
    }

    /// Compute root from leaf and proof (using Poseidon hash)
    pub fn compute_root(&self, leaf: &[u8; 32]) -> [u8; 32] {
        let mut current = *leaf;

        for i in 0..MERKLE_DEPTH {
            let sibling = &self.siblings[i];

            current = if self.path_indices[i] == 0 {
                // Current is on the left
                merkle_hash_2(&current, sibling)
            } else {
                // Current is on the right
                merkle_hash_2(sibling, &current)
            };
        }

        current
    }
}

impl Default for MerkleProof {
    fn default() -> Self {
        Self {
            siblings: [[0u8; 32]; MERKLE_DEPTH],
            path_indices: [0u8; MERKLE_DEPTH],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_poseidon_deterministic() {
        let a = [1u8; 32];
        let b = [2u8; 32];

        let h1 = merkle_hash_2(&a, &b);
        let h2 = merkle_hash_2(&a, &b);

        assert_eq!(h1, h2);
    }

    #[test]
    fn test_poseidon_different_order() {
        let a = [1u8; 32];
        let b = [2u8; 32];

        let h1 = merkle_hash_2(&a, &b);
        let h2 = merkle_hash_2(&b, &a);

        assert_ne!(h1, h2);
    }

    #[test]
    fn test_zero_hash_chain_poseidon() {
        // Verify precomputed zero hashes are consistent
        // Note: ZERO_HASHES are from circomlibjs (frontend) for ZK circuit compatibility
        // The on-chain code uses these precomputed values directly
        let zeros = compute_zero_hashes_poseidon();

        // Level 0 should be zero value
        assert_eq!(zeros[0], ZERO_VALUE, "Level 0 should be zero value");

        // Verify we have the correct number of levels
        assert_eq!(zeros.len(), MERKLE_DEPTH + 1);

        // Verify empty tree root matches
        assert_eq!(zeros[MERKLE_DEPTH], EMPTY_TREE_ROOT, "Empty tree root should match");

        // Verify each level is different (no accidental duplicates)
        for i in 0..MERKLE_DEPTH {
            assert_ne!(zeros[i], zeros[i + 1], "Adjacent levels should differ");
        }
    }
}
