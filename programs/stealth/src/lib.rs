//! # Shadowwire Protocol (StealthSol)
//!
//! Maximum privacy payments on Solana.
//!
//! ## For Frontend Developers (Shadowwire)
//!
//! **USE ONLY THESE 4 INSTRUCTIONS:**
//!
//! 1. `send_private` - Deposit to privacy pool
//! 2. `receive_private` - Withdraw to stealth address (AUTOMATIC)
//! 3. `register` - Register your meta-address
//! 4. `scan` - (off-chain) Scan for incoming payments
//!
//! **Privacy Score: 97%**
//!
//! Everything else (pools, addresses, proofs) is handled automatically.
//!
//! ## Architecture
//!
//! ```text
//! SHADOWWIRE (Frontend)
//!        │
//!        ▼
//! ┌─────────────────────────────────────────┐
//! │         UNIFIED PRIVACY FLOW            │
//! │  • Privacy Pool (hides amount + link)   │
//! │  • Stealth Address (hides recipient)    │
//! │  • Relayer (hides sender)               │
//! │  • Commit-Reveal (hides timing)         │
//! └─────────────────────────────────────────┘
//! ```

#![allow(unexpected_cfgs)]
#![allow(deprecated)]

use anchor_lang::prelude::*;

pub mod crypto;
pub mod error;
pub mod instructions;
pub mod state;
pub mod zk;

#[cfg(test)]
mod tests;

use instructions::*;

declare_id!("3D37zdZf1nQ9RtPsobc7kX6hR8SvieBbqQWBTZwhMzBT");

#[program]
pub mod stealth {
    use super::*;

    // =========================================================================
    //
    //                    SHADOWWIRE PUBLIC API
    //
    //          These are the ONLY instructions frontends should use.
    //          Everything else is internal/admin.
    //
    // =========================================================================

    // -------------------------------------------------------------------------
    // IDENTITY: Register your stealth meta-address
    // -------------------------------------------------------------------------

    /// Register your stealth identity
    ///
    /// Creates your meta-address (S, B) so others can send you private payments.
    /// Call this once per user.
    ///
    /// # Arguments
    /// * `scan_pubkey` - Your scan public key (can delegate to scanning service)
    /// * `spend_pubkey` - Your spend public key (NEVER share private key)
    /// * `label` - Optional 32-byte label (username hash, etc.)
    pub fn register(
        ctx: Context<Register>,
        scan_pubkey: [u8; 32],
        spend_pubkey: [u8; 32],
        label: [u8; 32],
    ) -> Result<()> {
        instructions::register(ctx, scan_pubkey, spend_pubkey, label)
    }

    /// Update your stealth identity
    ///
    /// Rotate keys while keeping the same registry.
    pub fn update_identity(
        ctx: Context<UpdateRegistry>,
        scan_pubkey: [u8; 32],
        spend_pubkey: [u8; 32],
        label: [u8; 32],
    ) -> Result<()> {
        instructions::update_registry(ctx, scan_pubkey, spend_pubkey, label)
    }

    // -------------------------------------------------------------------------
    // SEND: Private payment (deposit to pool)
    // -------------------------------------------------------------------------

    /// Send a private payment
    ///
    /// Deposits SOL into the privacy pool. Share the resulting note
    /// with the recipient off-chain (encrypted DM, QR code, etc.)
    ///
    /// # Arguments
    /// * `denomination` - Amount: 1_000_000_000 (1 SOL), 10B (10 SOL), 100B (100 SOL)
    /// * `commitment` - Hash of (nullifier, secret) - generated by SDK
    /// * `encrypted_note` - Optional encrypted note for recipient
    ///
    /// # Privacy
    /// - Amount hidden (fixed denominations only)
    /// - Your identity visible on deposit (use relayer for full privacy)
    pub fn send_private(
        ctx: Context<UnifiedDeposit>,
        denomination: u64,
        commitment: [u8; 32],
        encrypted_note: Option<[u8; 128]>,
    ) -> Result<()> {
        instructions::unified_deposit(ctx, denomination, commitment, encrypted_note)
    }

    // -------------------------------------------------------------------------
    // RECEIVE: Private withdrawal (to stealth address - AUTOMATIC)
    // -------------------------------------------------------------------------

    /// Receive a private payment
    ///
    /// Withdraws from the pool to a STEALTH ADDRESS (derived automatically).
    /// The recipient's identity is completely hidden.
    ///
    /// # Arguments
    /// * `denomination` - Must match the deposit amount
    /// * `proof` - ZK proof + recipient meta-address + ephemeral key
    /// * `relayer_fee` - Fee for relayer (0 if self-submitting)
    ///
    /// # Privacy (97%)
    /// - ✅ Amount hidden (fixed denomination)
    /// - ✅ Sender-receiver link hidden (ZK proof)
    /// - ✅ Recipient hidden (stealth address)
    /// - ✅ Transaction submitter hidden (relayer)
    pub fn receive_private(
        ctx: Context<UnifiedWithdraw>,
        denomination: u64,
        proof: UnifiedWithdrawProof,
        relayer_fee: u64,
    ) -> Result<()> {
        instructions::unified_withdraw(ctx, denomination, proof, relayer_fee)
    }

    // -------------------------------------------------------------------------
    // RECEIVE WITH TIMING PRIVACY: Commit-reveal for maximum privacy
    // -------------------------------------------------------------------------

    /// Commit to receiving (Step 1)
    ///
    /// Submit a hash of your withdrawal intent. Execute later within
    /// the time window. This prevents timing correlation attacks.
    ///
    /// # Arguments
    /// * `commitment_hash` - Hash of (proof, recipient, random, nonce)
    /// * `denomination` - Pool denomination
    /// * `min_delay_hours` - Minimum wait time (1-167 hours)
    /// * `max_delay_hours` - Maximum wait time (2-168 hours)
    pub fn commit_receive(
        ctx: Context<UnifiedCommit>,
        commitment_hash: [u8; 32],
        denomination: u64,
        min_delay_hours: u8,
        max_delay_hours: u8,
    ) -> Result<()> {
        instructions::unified_commit(ctx, commitment_hash, denomination, min_delay_hours, max_delay_hours)
    }

    /// Execute committed receive (Step 2)
    ///
    /// Reveal your intent and receive funds. Can be executed by anyone
    /// (keeper network) for maximum timing privacy.
    ///
    /// # Privacy (99%)
    /// - All benefits of receive_private
    /// - ✅ Timing hidden (commit-reveal)
    /// - ✅ Can be executed by keeper (user not online)
    pub fn execute_receive(
        ctx: Context<UnifiedReveal>,
        commitment_hash: [u8; 32],
        denomination: u64,
        nullifier_hash: [u8; 32],
        params: UnifiedRevealParams,
        relayer_fee: u64,
    ) -> Result<()> {
        instructions::unified_reveal(ctx, commitment_hash, denomination, nullifier_hash, params, relayer_fee)
    }

    // -------------------------------------------------------------------------
    // VIEW KEYS: Optional compliance/audit support
    // -------------------------------------------------------------------------

    /// Grant view access to an auditor
    ///
    /// The view key holder can see your transactions but CANNOT spend.
    /// Toggle on/off anytime.
    pub fn grant_view_access(
        ctx: Context<SetViewKey>,
        view_key: [u8; 32],
        holder: Pubkey,
    ) -> Result<()> {
        instructions::set_view_key(ctx, view_key, holder)
    }

    /// Toggle view access on/off
    pub fn toggle_view_access(ctx: Context<SetViewKey>, enabled: bool) -> Result<()> {
        instructions::toggle_view_key(ctx, enabled)
    }

    /// Revoke view access permanently
    pub fn revoke_view_access(ctx: Context<SetViewKey>) -> Result<()> {
        instructions::revoke_view_key(ctx)
    }

    // =========================================================================
    //
    //                    ADMIN / INFRASTRUCTURE
    //
    //          These instructions are for protocol operators only.
    //          Frontends should NOT call these directly.
    //
    // =========================================================================

    /// Initialize a privacy pool (ADMIN)
    pub fn initialize_pool(ctx: Context<InitializePool>, denomination: u64) -> Result<()> {
        instructions::initialize_pool(ctx, denomination)
    }

    /// Close a privacy pool (ADMIN) - for migration/cleanup
    pub fn close_pool(ctx: Context<ClosePool>, denomination: u64) -> Result<()> {
        instructions::close_pool(ctx, denomination)
    }

    /// Initialize relayer registry (ADMIN)
    pub fn initialize_relayer_registry(ctx: Context<InitializeRelayerRegistry>) -> Result<()> {
        instructions::initialize_relayer_registry(ctx)
    }

    /// Register as a relayer (RELAYER OPERATORS)
    pub fn register_relayer(
        ctx: Context<RegisterRelayer>,
        fee_bps: u16,
        min_fee: u64,
        max_fee: u64,
        supported_denominations: u8,
        stake_amount: u64,
    ) -> Result<()> {
        instructions::register_relayer(ctx, fee_bps, min_fee, max_fee, supported_denominations, stake_amount)
    }

    /// Update relayer settings (RELAYER OPERATORS)
    pub fn update_relayer(
        ctx: Context<UpdateRelayer>,
        fee_bps: Option<u16>,
        min_fee: Option<u64>,
        max_fee: Option<u64>,
        supported_denominations: Option<u8>,
        is_active: Option<bool>,
    ) -> Result<()> {
        instructions::update_relayer(ctx, fee_bps, min_fee, max_fee, supported_denominations, is_active)
    }

    /// Request relay (INTERNAL - called by SDK)
    pub fn request_relay(
        ctx: Context<RequestRelay>,
        tx_hash: [u8; 32],
        denomination: u64,
    ) -> Result<()> {
        instructions::request_relay(ctx, tx_hash, denomination)
    }

    /// Complete relay (RELAYER OPERATORS)
    pub fn complete_relay(
        ctx: Context<CompleteRelay>,
        tx_hash: [u8; 32],
    ) -> Result<()> {
        instructions::complete_relay(ctx, tx_hash)
    }

    /// Withdraw relayer stake (RELAYER OPERATORS)
    pub fn withdraw_relayer_stake(ctx: Context<WithdrawRelayerStake>) -> Result<()> {
        instructions::withdraw_relayer_stake(ctx)
    }

    /// Initialize decoy treasury (ADMIN)
    pub fn initialize_decoy_treasury(ctx: Context<InitializeDecoyTreasury>) -> Result<()> {
        instructions::initialize_decoy_treasury(ctx)
    }

    /// Fund decoy treasury (ADMIN)
    pub fn fund_decoy_treasury(ctx: Context<FundDecoyTreasury>, amount: u64) -> Result<()> {
        instructions::fund_decoy_treasury(ctx, amount)
    }

    /// Register decoy wallet (ADMIN)
    pub fn register_decoy_wallet(ctx: Context<RegisterDecoyWallet>, wallet: Pubkey) -> Result<()> {
        instructions::register_decoy_wallet(ctx, wallet)
    }

    /// Update decoy config (ADMIN)
    pub fn update_decoy_config(
        ctx: Context<UpdateDecoyConfig>,
        fee_bps: Option<u16>,
        min_decoys: Option<u8>,
        max_decoys: Option<u8>,
        min_delay: Option<u32>,
        max_delay: Option<u32>,
        min_hold: Option<u32>,
        max_hold: Option<u32>,
        auto_decoy: Option<bool>,
    ) -> Result<()> {
        instructions::update_decoy_config(ctx, fee_bps, min_decoys, max_decoys, min_delay, max_delay, min_hold, max_hold, auto_decoy)
    }

    /// Record decoy deposit (DECOY BOT)
    pub fn record_decoy_deposit(ctx: Context<RecordDecoyDeposit>, denomination: u64, tx_fee: u64) -> Result<()> {
        instructions::record_decoy_deposit(ctx, denomination, tx_fee)
    }

    /// Record decoy withdrawal (DECOY BOT)
    pub fn record_decoy_withdraw(ctx: Context<RecordDecoyWithdraw>, amount_returned: u64, tx_fee: u64) -> Result<()> {
        instructions::record_decoy_withdraw(ctx, amount_returned, tx_fee)
    }

    /// Toggle decoy system (ADMIN)
    pub fn toggle_decoy_system(ctx: Context<ToggleDecoySystem>, active: bool) -> Result<()> {
        instructions::toggle_decoy_system(ctx, active)
    }

    /// Initialize announcement log (ADMIN)
    pub fn initialize_announcement_log(ctx: Context<InitializeAnnouncementLog>, log_id: u64) -> Result<()> {
        instructions::initialize_announcement_log(ctx, log_id)
    }

    /// Deactivate announcement log (ADMIN)
    pub fn deactivate_announcement_log(ctx: Context<DeactivateLog>) -> Result<()> {
        instructions::deactivate_announcement_log(ctx)
    }

    // =========================================================================
    //
    //                    LEGACY / DIRECT ACCESS
    //
    //          These instructions exist for backwards compatibility
    //          and advanced users who need direct pool/stealth access.
    //
    //          NOT RECOMMENDED for Shadowwire frontend.
    //
    // =========================================================================

    /// Direct stealth send (LEGACY - use send_private instead)
    #[deprecated(note = "Use send_private for maximum privacy")]
    pub fn stealth_send(
        ctx: Context<StealthSend>,
        ephemeral_pubkey: [u8; 32],
        commitment: [u8; 32],
        amount: u64,
    ) -> Result<()> {
        instructions::stealth_send(ctx, ephemeral_pubkey, commitment, amount)
    }

    /// Direct stealth send to meta-address (LEGACY)
    #[deprecated(note = "Use send_private for maximum privacy")]
    pub fn stealth_send_direct(
        ctx: Context<StealthSendDirect>,
        scan_pubkey: [u8; 32],
        spend_pubkey: [u8; 32],
        ephemeral_pubkey: [u8; 32],
        commitment: [u8; 32],
        amount: u64,
    ) -> Result<()> {
        instructions::stealth_send_direct(ctx, scan_pubkey, spend_pubkey, ephemeral_pubkey, commitment, amount)
    }

    /// Direct withdrawal from stealth address (LEGACY)
    #[deprecated(note = "Use receive_private for maximum privacy")]
    pub fn withdraw(ctx: Context<Withdraw>) -> Result<()> {
        instructions::withdraw(ctx)
    }

    /// Direct partial withdrawal (LEGACY)
    #[deprecated(note = "Use receive_private for maximum privacy")]
    pub fn withdraw_partial(ctx: Context<WithdrawPartial>, amount: u64) -> Result<()> {
        instructions::withdraw_partial(ctx, amount)
    }

    /// Direct pool deposit (LEGACY - use send_private instead)
    #[deprecated(note = "Use send_private for maximum privacy")]
    pub fn private_deposit(
        ctx: Context<PrivateDeposit>,
        denomination: u64,
        commitment: [u8; 32],
        encrypted_note: Option<[u8; 128]>,
    ) -> Result<()> {
        instructions::private_deposit(ctx, denomination, commitment, encrypted_note)
    }

    /// Direct pool withdrawal (LEGACY - use receive_private instead)
    #[deprecated(note = "Use receive_private for maximum privacy")]
    pub fn private_withdraw(
        ctx: Context<PrivateWithdraw>,
        denomination: u64,
        proof: WithdrawProof,
        relayer_fee: u64,
    ) -> Result<()> {
        instructions::private_withdraw(ctx, denomination, proof, relayer_fee)
    }

    /// Batch deposit (LEGACY)
    #[deprecated(note = "Use send_private for maximum privacy")]
    pub fn batch_deposit(
        ctx: Context<BatchDeposit>,
        commitments: Vec<[u8; 32]>,
        total_amount: u64,
    ) -> Result<()> {
        instructions::batch_deposit(ctx, commitments, total_amount)
    }

    /// Private transfer (LEGACY)
    #[deprecated(note = "Use send_private + receive_private for maximum privacy")]
    pub fn private_transfer(
        ctx: Context<PrivateTransfer>,
        denomination: u64,
        proof: TransferProof,
    ) -> Result<()> {
        instructions::private_transfer(ctx, denomination, proof)
    }

    /// Blended transfer (LEGACY)
    #[deprecated(note = "Use send_private for maximum privacy")]
    pub fn blended_transfer(
        ctx: Context<BlendedTransfer>,
        amount: u64,
        memo: TransferMemo,
    ) -> Result<()> {
        instructions::blended_transfer(ctx, amount, memo)
    }

    /// Blended transfer with log (LEGACY)
    #[deprecated(note = "Use send_private for maximum privacy")]
    pub fn blended_transfer_with_log(
        ctx: Context<BlendedTransferWithLog>,
        amount: u64,
        memo: TransferMemo,
    ) -> Result<()> {
        instructions::blended_transfer_with_log(ctx, amount, memo)
    }

    /// Commit withdrawal (LEGACY - use commit_receive instead)
    #[deprecated(note = "Use commit_receive for unified flow")]
    pub fn commit_withdrawal(
        ctx: Context<CommitWithdrawal>,
        commitment_hash: [u8; 32],
        denomination: u64,
        min_delay_hours: u8,
        max_delay_hours: u8,
    ) -> Result<()> {
        instructions::commit_withdrawal(ctx, commitment_hash, denomination, min_delay_hours, max_delay_hours)
    }

    /// Reveal withdrawal (LEGACY - use execute_receive instead)
    #[deprecated(note = "Use execute_receive for unified flow")]
    pub fn reveal_and_withdraw(
        ctx: Context<RevealWithdrawal>,
        commitment_hash: [u8; 32],
        denomination: u64,
        proof_hash: [u8; 32],
        user_random: [u8; 32],
        nonce: u64,
        relayer_fee: u64,
    ) -> Result<()> {
        instructions::reveal_and_withdraw(ctx, commitment_hash, denomination, proof_hash, user_random, nonce, relayer_fee)
    }

    /// Cancel commitment (INTERNAL)
    pub fn cancel_commitment(ctx: Context<CancelCommitment>, commitment_hash: [u8; 32]) -> Result<()> {
        instructions::cancel_commitment(ctx, commitment_hash)
    }

    /// Close commitment (INTERNAL)
    pub fn close_commitment(ctx: Context<CloseCommitment>, commitment_hash: [u8; 32]) -> Result<()> {
        instructions::close_commitment(ctx, commitment_hash)
    }

    /// Submit keeper intent (ADVANCED)
    pub fn submit_keeper_intent(
        ctx: Context<SubmitKeeperIntent>,
        intent_id: [u8; 32],
        encrypted_payload: Vec<u8>,
        window_start_offset_hours: u8,
        window_duration_hours: u8,
        denomination: u64,
        keeper_fee: u64,
    ) -> Result<()> {
        instructions::submit_keeper_intent(ctx, intent_id, encrypted_payload, window_start_offset_hours, window_duration_hours, denomination, keeper_fee)
    }

    /// Execute keeper intent (KEEPER OPERATORS)
    pub fn execute_keeper_intent(
        ctx: Context<ExecuteKeeperIntent>,
        intent_id: [u8; 32],
        denomination: u64,
        nullifier_hash: [u8; 32],
        proof_attestation: [u8; 64],
    ) -> Result<()> {
        instructions::execute_keeper_intent(ctx, intent_id, denomination, nullifier_hash, proof_attestation)
    }

    /// Cancel keeper intent (INTERNAL)
    pub fn cancel_keeper_intent(ctx: Context<CancelKeeperIntent>, intent_id: [u8; 32]) -> Result<()> {
        instructions::cancel_keeper_intent(ctx, intent_id)
    }

    /// Claim expired intent (INTERNAL)
    pub fn claim_expired_intent(ctx: Context<ClaimExpiredIntent>, intent_id: [u8; 32]) -> Result<()> {
        instructions::claim_expired_intent(ctx, intent_id)
    }

    /// Rotate view key (INTERNAL)
    pub fn rotate_view_key(ctx: Context<SetViewKey>, new_view_key: [u8; 32], new_holder: Pubkey) -> Result<()> {
        instructions::rotate_view_key(ctx, new_view_key, new_holder)
    }

    /// Verify view access (INTERNAL)
    pub fn verify_view_access(ctx: Context<VerifyViewAccess>) -> Result<()> {
        instructions::verify_view_access(ctx)
    }

    /// Get relayer info (INTERNAL)
    pub fn get_relayer_info(ctx: Context<GetRelayerInfo>) -> Result<()> {
        instructions::get_relayer_info(ctx)
    }

    /// Initialize verification key (DISABLED - Solana 2.0)
    #[allow(unused_variables)]
    pub fn initialize_verification_key(ctx: Context<InitializeVerificationKey>, vk_data: Vec<u8>) -> Result<()> {
        instructions::initialize_verification_key(ctx, vk_data)
    }

    /// Update verification key (DISABLED - Solana 2.0)
    pub fn update_verification_key(ctx: Context<UpdateVerificationKey>, vk_data: Vec<u8>) -> Result<()> {
        instructions::update_verification_key(ctx, vk_data)
    }

    /// Verified withdrawal with ON-CHAIN Groth16 verification
    ///
    /// Unlike oracle-based withdrawals, this instruction verifies the ZK proof
    /// directly on-chain using Solana's alt_bn128 precompiles (~200k CUs).
    ///
    /// # Arguments
    /// * `denomination` - Pool denomination
    /// * `public_inputs` - Groth16 public inputs (merkle_root, nullifier_hash, recipient, amount)
    /// * `proof` - Groth16 proof (A, B, C points)
    /// * `relayer_fee` - Fee for relayer
    ///
    /// # Privacy (100%)
    /// - ✅ Amount hidden (fixed denomination)
    /// - ✅ Sender-receiver link hidden (ZK proof)
    /// - ✅ Trustless verification (no oracle needed)
    /// - ✅ Transaction submitter hidden (relayer)
    pub fn verified_withdraw(
        ctx: Context<VerifiedWithdraw>,
        denomination: u64,
        public_inputs: Groth16WithdrawInputs,
        proof: zk::Groth16Proof,
        relayer_fee: u64,
    ) -> Result<()> {
        instructions::verified_withdraw(ctx, denomination, public_inputs, proof, relayer_fee)
    }

    /// Simple deposit - stores commitment without on-chain Merkle computation
    ///
    /// # Arguments
    /// * `denomination` - Pool denomination
    /// * `commitment` - Pre-computed commitment
    /// * `merkle_root` - Off-chain computed Merkle root
    pub fn simple_deposit(
        ctx: Context<SimpleDeposit>,
        denomination: u64,
        commitment: [u8; 32],
        merkle_root: [u8; 32],
    ) -> Result<()> {
        instructions::simple_deposit(ctx, denomination, commitment, merkle_root)
    }

    /// Verified stealth send (DISABLED - Solana 2.0)
    #[allow(unused_variables)]
    pub fn verified_stealth_send(
        ctx: Context<VerifiedStealthSend>,
        ephemeral_pubkey: [u8; 32],
        commitment: [u8; 32],
        amount: u64,
        proof: zk::Groth16Proof,
    ) -> Result<()> {
        instructions::verified_stealth_send(ctx, ephemeral_pubkey, commitment, amount, proof)
    }

    // ==========================================
    // DENOMINATION REGISTRY INSTRUCTIONS
    // ==========================================

    /// Initialize the denomination registry
    pub fn initialize_denomination_registry(ctx: Context<InitializeDenominationRegistry>) -> Result<()> {
        instructions::initialize_denomination_registry(ctx)
    }

    /// Add a new denomination to the registry
    pub fn add_denomination(ctx: Context<UpdateDenominationRegistry>, denomination: u64) -> Result<()> {
        instructions::add_denomination(ctx, denomination)
    }

    /// Remove a denomination from the registry
    pub fn remove_denomination(ctx: Context<UpdateDenominationRegistry>, denomination: u64) -> Result<()> {
        instructions::remove_denomination(ctx, denomination)
    }

    /// Update registry configuration
    pub fn update_registry_config(
        ctx: Context<UpdateDenominationRegistry>,
        allow_custom: Option<bool>,
        min_denomination: Option<u64>,
        max_denomination: Option<u64>,
    ) -> Result<()> {
        instructions::update_registry_config(ctx, allow_custom, min_denomination, max_denomination)
    }

    /// Transfer registry authority
    pub fn transfer_registry_authority(
        ctx: Context<UpdateDenominationRegistry>,
        new_authority: Pubkey,
    ) -> Result<()> {
        instructions::transfer_registry_authority(ctx, new_authority)
    }
}
