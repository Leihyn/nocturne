{"noir_version":"0.38.0+e784523a15c0c233a5a794f28498635b7ce86325","hash":16373897829741550655,"abi":{"parameters":[{"name":"commitment","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"30":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"31":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"32":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"69":{"source":"// StealthSol Deposit Circuit\n//\n// Proves that a commitment was correctly constructed from:\n// - nullifier (private): random value for double-spend prevention\n// - secret (private): random blinding factor\n// - amount (private): deposit amount in lamports\n// - recipient (private): stealth address of recipient\n//\n// Public output: commitment hash\n// This allows deposits without revealing the recipient or amount on-chain\n\nuse std::hash::poseidon;\n\n// Poseidon hash for 4 inputs (optimized for ZK)\nfn poseidon_hash_4(inputs: [Field; 4]) -> Field {\n    poseidon::bn254::hash_4(inputs)\n}\n\n// Main deposit circuit\nfn main(\n    // Public inputs (visible on-chain)\n    commitment: pub Field,\n\n    // Private inputs (hidden from everyone)\n    nullifier: Field,\n    secret: Field,\n    amount: Field,\n    recipient: Field,\n) {\n    // Constraint 1: Commitment is correctly computed\n    // commitment = Poseidon(nullifier, secret, amount, recipient)\n    let computed_commitment = poseidon_hash_4([nullifier, secret, amount, recipient]);\n    assert(computed_commitment == commitment);\n\n    // Constraint 2: Amount must be positive\n    // We check this by ensuring amount fits in u64\n    let amount_u64 = amount as u64;\n    assert(amount_u64 > 0);\n\n    // Constraint 3: Nullifier must be non-zero (prevents trivial nullifiers)\n    assert(nullifier != 0);\n\n    // Constraint 4: Secret must be non-zero (prevents trivial secrets)\n    assert(secret != 0);\n}\n\n// Test the circuit with sample values\n#[test]\nfn test_deposit_circuit() {\n    // Use values within BN254 field (< 2^254)\n    let nullifier: Field = 0x1234567890abcdef1234567890abcdef;\n    let secret: Field = 0xfedcba0987654321fedcba0987654321;\n    let amount: Field = 1000000000; // 1 SOL in lamports\n    let recipient: Field = 0xabcdef1234567890abcdef1234567890;\n\n    let commitment = poseidon_hash_4([nullifier, secret, amount, recipient]);\n\n    main(commitment, nullifier, secret, amount, recipient);\n}\n","path":"/Users/machine/Desktop/dev/github_repos/Privacy/stealthsol/circuits/noir/deposit/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}